There is some shellcode, the main problem that IDA cannot show you passed arguments to shellcode and you need to understand it.
```
void __noreturn start()
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  MD5::MD5(&v6);
  v0 = GetProcessHeap(0, 16);
  v7 = HeapAlloc(v0, v1, v2);
  *v7 = final_str;
  v3 = strlen(final_str);
  v7[1] = v3;
  Dst = VirtualAlloc(0, 13, 4096, 64);
  memcpy(Dst, sub_404068, 13u);
  (Dst)();
  v5 = MD5::digestString(&v6, final_str);
  MessageBoxA(0, v5, "We've been compromised!", 48);
  ExitProcess(0);
}
```
Looks like this Dst call did not get anything, but its wrong.
```
.text:004022C0                 call    ds:VirtualAlloc
.text:004022C6                 mov     [ebp+Dst], eax
.text:004022CC                 push    0Dh             ; MaxCount
.text:004022CE                 push    offset sub_404068 ; Src
.text:004022D3                 mov     edx, [ebp+Dst]
.text:004022D9                 push    edx             ; Dst
.text:004022DA                 call    memcpy
.text:004022DF                 add     esp, 0Ch
.text:004022E2                 mov     esi, [ebp+var_4]
.text:004022E5                 call    [ebp+Dst]
```

In asm we can see esi passed. And shellcode using it aswell
```
.data:00404068 shellcode       proc near               ; DATA XREF: start+5E↑o
.data:00404068                 mov     edi, [esi]      ; deref esi
.data:0040406A                 mov     ecx, [esi+4]    ; reref esi + 4
.data:0040406D
.data:0040406D loc_40406D:                             ; CODE XREF: shellcode+A↓j
.data:0040406D                 rol     byte ptr [edi+ecx-1], 5
.data:00404072                 loop    loc_40406D
.data:00404074                 retn
.data:00404074 shellcode       endp
```

So its pointer to char* and its size, like
```
struct str_t {
    char* ptr;
    uint32_t size;
};
```

Now let's think what shellcode does: It takes last array symbol and rol it to 5, than ecx decreases to 1. So we can just rol every byte to 5, or we can rebuild it and see how its going.
